#! /bin/sh
workdir="$HOME/Projects/Android/Scullery"
scullibdir="/usr/lib/scullery"
scullplugdir="$HOME/.config/scullery/plugins"
ifacestyle="term"
romdir="$HOME/Projects/Android/ROMS/"
rompath="/this/is/not/a/real/folder/update.zip"
version=""
installdeps="false"
if [ -f "$HOME/.scullery" ]; then
    . "$HOME/.scullery"
elif [ -f /etc/scullery.rc ]; then
    . /etc/scullery.rc
else
    echo "Critical Error! Configuration file not found. Please place a config
file in either /etc/scullery.rc or \$HOME/.scullery"
    exit 1
fi

show_help(){
    echo "Welcome to Android Scullery! This is a fully re-written version of the
Android Kitchen ROM customization tools. It's a GNU/Linux shell script written
to target the Dash shell, but it should work with any shell. Since you're asking
for help, I bet you want to know these parameters:
        -h || -?)
        -v) Run with verbose output.
        -d) Specify a working directory.
        -r) Specify a ROM directory where scullery will look for ROMs to modify.
        -f) Specify a ROM file/folder to modify.
        -l) Specify a path to look for the library of scripts.
        -p) Specify a plugin directory to look for custom scripts in.
        -i) Specify a style of interface to present when options are required.
            term || cli : Run with terminal interface.
            diag || wiz : Run with wizard-like GUI.
            gui : Run with frontend.
        -e) Install
"
}

# A POSIX variable
OPTIND=1         # Reset in case getopts has been used previously in the shell.

# Initialize our own variables:
verbose=0

while getopts "h?vdrflpie:" opt; do
    case "$opt" in
    h|\?)
        show_help
        exit 0
        ;;
    v)  verbose=1
        ;;
    d)  workdir=$OPTARG
        ;;
    r)  romdir=$OPTARG
        ;;
    f)  rompath=$OPTARG
        ;;
    l)  scullibdir=$OPTARG
        ;;
    p)  scullplugdir=$OPTARG
        ;;
    i)  ifacestyle=$OPTARG
        ;;
    i)  installdeps="true"
        ;;
    esac
done

shift $((OPTIND-1))

[ "$1" = "--" ] && shift

if [ "$installdeps" = "true" ]; then
    sudo apt-get install abootimg android-tools*
fi

if [ ! -d "$scullibdir" ]; then
    echo "Critical Error! Library folder not found!"
    exit 2
fi
if [ ! -f "$scullibdir/*" ]; then
    echo "Critical Error! Library folder not populated!"
    exit 3
fi
if [ ! -d "$workdir" ]; then
    mkdir -p "$workdir"
fi
if [ ! -d "$romdir" ]; then
    mkdir -p "$romdir"
    mkdir -p "$romdir/compiled_roms"
fi
if [ ! -d "$scullplugdir" ]; then
    mkdir -p "$scullplugdir"
fi
if [ [ "$ifacestyle" = "term" ] || [ "$ifacestyle" = "cli" ] ]; then
    if [ ! -f /usr/bin/wgdda ]; then
        if [ -f /usr/bin/whiptail ]; then
            alias dialog=whiptail
        elif [ -f /usr/bin/dialog ]; then
            alias dialog=dialog
        else
            echo "Critical Error! Interface Dependency not satisfied(Install either
whiptail or dialog.)"
            exit 4
        fi
    else
        NOGUI_DIALOG="true"
        . wgdda
    fi
elif [ [ "$ifacestyle" == "dial" ] || [ "$ifacestyle" == "wiz" ] ]; then
    if [ ! -f /usr/bin/wgdda ]; then
        if [ -f /usr/bin/zenity ]; then
            alias dialog=zenity
        elif [ -f /usr/bin/xdialog ]; then
            alias dialog=xdialog
        else
            echo "Critical Error! Interface Dependency not satisfied(Install either
zenity or xdialog.)"
            exit 4
        fi
    else
        NOGUI_DIALOG=""
        . wgdda
    fi
elif [ "$ifacestyle" == "gui" ]
    echo "Critical Error! Interface not yet supported."
    exit 5
else 
    echo "Critical Error! Invalid interface style specified."
    exit 6
fi
    . $scullibdir/functions.sh
if [ -f "$rompath" ]; then
    . $scullibdir/extract_rom "$rompath"
else
    
fi
#! /bin/sh

# roughly maps onto the check_rom script in the original Android Kitchen, which
# validates an input ROM and sets up a working directory. Some of the check_rom
# functionality was separated into other scripts. That will be done with both
# scripts and functions here.

EXTRACT_ROM_TITLE="CREATE WORKING FOLDER FOR ROM"
EXTRACT_ROM_MESSAGE="Ensure there is at least one ROM under the \"$romdir\" folder!

Select an option:
"
EXTRACT_OR_SHOW=0

ROM_FORMATS_MESSAGE=$(cat "$scullibdir/formats.txt")
echo $ROM_FORMATS_MESSAGE

extract_or_show(){
    EXTRACT_OR_SHOW=$(dialog --title "$EXTRACT_ROM_TITLE" --menu "$EXTRACT_ROM_MESSAGE" 14 60 2 \
        1 "Show supported formats:" \
        2 "Continue to ROM select menu" \
        3>&1 1>&2 2>&3 3>&- )
}

loopover(){
    if [ $EXTRACT_OR_SHOW = 0 ]; then
        extract_or_show
    elif [ $EXTRACT_OR_SHOW = 1 ]; then
        dialog --title "$EXTRACT_ROM_TITLE" --msgbox "$ROM_FORMATS_MESSAGE" 14 80
    elif [ $EXTRACT_OR_SHOW = 2 ]; then
        ROMS_AVAILABLE=checkout_romdir
        WHICH_ROM=$(dialog --title "$EXTRACT_ROM_TITLE" --menu "$EXTRACT_ROM_FROM_AVAIL" 14 80 2 \
            "$ROMS_AVAILABLE" \
            3>&1 1>&2 2>&3 3>&-)
    fi
}

while [ $EXTRACT_OR_SHOW = 0 ]; do
    loopover
done
loopover
echo $ROMS_AVAILABLE
#! /bin/sh
#DO NOT INCLUDE THIS FILE IN YOUR OWN SCRIPTS(Unless you only want them to be
#runnable in the kitchen. Instead include libfunctions.sh, which makes sure to 
#load the correct default configuration options for running the scripts before
#loading this exact file.

#This creates a list of whitespace separated pairs representing the files in the
#configured ROM search path($romdir). The output can be passed to dialog to
#create a ROM menu.
checkout_romdir(){
    c=0
    tmp=""
    for f in $romdir; do
        c=$((c+1))
        tmp=" $c $f "
    done
    echo $tmp
}

#
#

----------------------------------------------------------------------

The format for each ROM must be one of the following:
 
 - system.img + optional boot.img/lib.img (e.g. stock ROM or Nandroid)
 - ZIP file for a custom ROM              (e.g. update.zip)
 - ZIP file containing *.img              (e.g. stock rom.zip)
 - ZIP file containing shipped ROM in SYSTEM + BOOT folder format
 - Working folder made with this kitchen  (e.g. WORKING_old_rom)
 
 Other formats:
 
 Samsung Galaxy S:
 - factoryfs.rfs + optional cache.rfs/zImage
 - PDA.tar.md5 + optional CSC.tar.md5/PHONE.tar.md5
 - PDA.tar + optional CSC.tar/PHONE.tar
 - TAR/ZIP file containing the above 

 Samsung Galaxy S Plus:
 - system.img.ext4 + optional cache.img.ext4/boot.img
 - TAR/ZIP file containing the above
 
 Samsung Galaxy SII:
 - factoryfs.img + optional hidden.img/cache.img/zImage  
 - system.img.ext4 + optional cache.img.ext4/boot.img
 - TAR/ZIP file containing the above
 - system.ext4.tar + optional boot.img (Nandroid backup)
 
 Samsung Galaxy SIII / Galaxy Note II / Galaxy S4
 - system.img.ext4 + optional tomb.img.ext4/cache.img.ext4/boot.img
 - system.img + optional cache.img/boot.img/modem.bin
 - system.img.ext4 + optional cache.img/boot.img/modem.bin
 - TAR/ZIP file containing the above
 - system.ext4.tar + optional boot.img (Nandroid backup)

 Samsung - untested devices (e.g. Galaxy Mini):
 - system.rfs + optional csc.rfs/boot.img
 - TAR/ZIP file containing the above

 Huawei:
 - APP file from Huawei software update (e.g. UPDATE.APP)

 ----------------------------------------------------------------------
 
